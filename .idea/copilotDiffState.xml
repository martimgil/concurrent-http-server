<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/semaphores.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/semaphores.c" />
              <option name="originalContent" value="#include &quot;semaphores.h&quot;&#10;#include &lt;fcntl.h&gt;&#10;&#10;// Inicializa e dentroi POSIX semaforos usados na sincronização com um servidor multi-theread&#10;int init_semaphores(semaphores_t* sems, int queue_size) {&#10;    sems-&gt;empty_slots = sem_open(&quot;/ws_empty&quot;, O_CREAT, 0666, queue_size);&#10;    sems-&gt;filled_slots = sem_open(&quot;/ws_filled&quot;, O_CREAT, 0666, 0);&#10;    sems-&gt;queue_mutex = sem_open(&quot;/ws_queue_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;stats_mutex = sem_open(&quot;/ws_stats_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;log_mutex = sem_open(&quot;/ws_log_mutex&quot;, O_CREAT, 0666, 1);&#10;&#10;    if (sems-&gt;empty_slots == SEM_FAILED || sems-&gt;filled_slots == SEM_FAILED || sems-&gt;queue_mutex == SEM_FAILED || sems-&gt;stats_mutex == SEM_FAILED || sems-&gt;log_mutex == SEM_FAILED) {&#10;        return -1;&#10;    }&#10;    return 0;&#10;}&#10;&#10;void destroy_semaphores(semaphores_t* sems) {&#10;&#10;    sem_close(sems-&gt;empty_slots);&#10;    sem_close(sems-&gt;filled_slots);&#10;    sem_close(sems-&gt;queue_mutex);&#10;    sem_close(sems-&gt;stats_mutex);&#10;    _close(sems-&gt;log_mutex);&#10;&#10;    sem_unlink(&quot;/ws_empty&quot;);&#10;    sem_unlink(&quot;/ws_filled&quot;);&#10;    sem_unlink(&quot;/ws_queue_mutex&quot;);&#10;    sem_unlink(&quot;/ws_stats_mutex&quot;);&#10;" />
              <option name="updatedContent" value="#include &quot;semaphores.h&quot;&#10;#include &lt;fcntl.h&gt;&#10;&#10;// Inicializa e dentroi POSIX semaforos usados na sincronização com um servidor multi-theread&#10;int init_semaphores(semaphores_t* sems, int queue_size) {&#10;    sems-&gt;empty_slots = sem_open(&quot;/ws_empty&quot;, O_CREAT, 0666, queue_size);&#10;    sems-&gt;filled_slots = sem_open(&quot;/ws_filled&quot;, O_CREAT, 0666, 0);&#10;    sems-&gt;queue_mutex = sem_open(&quot;/ws_queue_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;stats_mutex = sem_open(&quot;/ws_stats_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;log_mutex = sem_open(&quot;/ws_log_mutex&quot;, O_CREAT, 0666, 1);&#10;&#10;    if (sems-&gt;empty_slots == SEM_FAILED || sems-&gt;filled_slots == SEM_FAILED || sems-&gt;queue_mutex == SEM_FAILED || sems-&gt;stats_mutex == SEM_FAILED || sems-&gt;log_mutex == SEM_FAILED) {&#10;        return -1;&#10;    }&#10;    return 0;&#10;}&#10;&#10;void destroy_semaphores(semaphores_t* sems) {&#10;    if (!sems) return;&#10;&#10;    sem_close(sems-&gt;empty_slots);&#10;    sem_close(sems-&gt;filled_slots);&#10;    sem_close(sems-&gt;queue_mutex);&#10;    sem_close(sems-&gt;stats_mutex);&#10;    sem_close(sems-&gt;log_mutex);&#10;&#10;    sem_unlink(&quot;/ws_empty&quot;);&#10;    sem_unlink(&quot;/ws_filled&quot;);&#10;    sem_unlink(&quot;/ws_queue_mutex&quot;);&#10;    sem_unlink(&quot;/ws_stats_mutex&quot;);&#10;    sem_unlink(&quot;/ws_log_mutex&quot;);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/thread_pool.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/thread_pool.c" />
              <option name="originalContent" value="#include &quot;thread_pool.h&quot;&#10;#include &lt;stdlib.h&gt;&#10;&#10;// É o loop principal para um worker numa thread pool&#10;// Espera pelo trabalho para estar disponviel e verifica se a pool esta a ser deslifada&#10;// Processa as tarefas da queue&#10;// Se o shutdown flag for ativado, sai do loop e termina a thread e o loop termina&#10;// Garante que todas as threads terminem ao desligar a pool&#10;&#10;void* worker_thread(void* arg) {&#10;    thread_pool_t* pool = (thread_pool_t*)arg;&#10;&#10;    while (1) {&#10;        pthread_mutex_lock(&amp;pool-&gt;mutex);&#10;&#10;        while (!pool-&gt;shutdown /* &amp;&amp; queue is empty */) {&#10;            pthread_cond_wait(&amp;pool-&gt;cond, &amp;pool-&gt;mutex);&#10;        }&#10;&#10;        if (pool-&gt;shutdown) {&#10;            pthread_mutex_unlock(&amp;pool-&gt;mutex);&#10;            break;&#10;        }&#10;&#10;        // Dequeue work item and process&#10;&#10;        pthread_mutex_unlock(&amp;pool-&gt;mutex);&#10;    }&#10;    return NULL;&#10;}&#10;&#10;thread_pool_t* create_thread_pool(int num_threads) {&#10;    thread_pool_t* pool = malloc(sizeof(thread_pool_t));&#10;    pool-&gt;threads = malloc(sizeof(pthread_t) * num_threads);&#10;    pool-&gt;num_threads = num_threads;&#10;    pool-&gt;shutdown = 0;&#10;&#10;    pthread_mutex_init(&amp;pool-&gt;mutex, NULL);&#10;    pthread_cond_init(&amp;pool-&gt;cond, NULL);&#10;&#10;    for (int i = 0; i &lt; num_threads; i++) {&#10;        pthread_create(&amp;pool-&gt;threads[i], NULL, worker_thread, pool);&#10;    }&#10;&#10;    return pool;&#10;}" />
              <option name="updatedContent" value="#include &quot;thread_pool.h&quot;&#10;#include &lt;stdlib.h&gt;&#10;&#10;// É o loop principal para um worker numa thread pool&#10;// Espera pelo trabalho para estar disponviel e verifica se a pool esta a ser deslifada&#10;// Processa as tarefas da queue&#10;// Se o shutdown flag for ativado, sai do loop e termina a thread e o loop termina&#10;// Garante que todas as threads terminem ao desligar a pool&#10;&#10;// worker_thread is now defined in master.c&#10;&#10;thread_pool_t* create_thread_pool(int num_threads) {&#10;    thread_pool_t* pool = malloc(sizeof(thread_pool_t));&#10;    pool-&gt;threads = malloc(sizeof(pthread_t) * num_threads);&#10;    pool-&gt;num_threads = num_threads;&#10;    pool-&gt;shutdown = 0;&#10;&#10;    pthread_mutex_init(&amp;pool-&gt;mutex, NULL);&#10;    pthread_cond_init(&amp;pool-&gt;cond, NULL);&#10;&#10;    for (int i = 0; i &lt; num_threads; i++) {&#10;        pthread_create(&amp;pool-&gt;threads[i], NULL, worker_thread, pool);&#10;    }&#10;&#10;    return pool;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>