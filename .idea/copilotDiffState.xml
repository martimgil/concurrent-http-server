<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/master.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/master.c" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#include &lt;stdio.h&gt;&#10;#include &lt;stdlib.h&gt;&#10;#include &lt;unistd.h&gt;&#10;#include &lt;sys/socket.h&gt;&#10;#include &lt;netinet/in.h&gt;&#10;#include &lt;signal.h&gt;&#10;#include &lt;pthread.h&gt;&#10;#include &lt;semaphore.h&gt;&#10;#include &quot;semaphores.h&quot;&#10;#include &quot;shared_mem.h&quot;&#10;#include &lt;errno.h&gt;&#10;#include &lt;string.h&gt;&#10;&#10;// Implementa a logica principal de aceitar conexoes do cliente.&#10;// É aqui a parte central da arquitetira multi-thread do servidor.&#10;&#10;#define PORT 8080&#10;#define MAX_WORKERS 4&#10;#define MAX_QUEUE_SIZE 100&#10;&#10;typedef struct {&#10;    shared_data_t* data;&#10;    semaphores_t* sems;&#10;} thread_args_t;&#10;&#10;volatile sig_atomic_t keep_running = 1;&#10;&#10;void signal_handler(int signum) {&#10;    (void)signum; // Mark as intentionally unused&#10;    keep_running = 0;&#10;}&#10;&#10;int create_server_socket(int port) {&#10;    int sockfd = socket(AF_INET, SOCK_STREAM, 0);&#10;    if (sockfd &lt; 0) {&#10;        perror(&quot;socket creation failed&quot;);&#10;        return -1;&#10;    }&#10;&#10;    int opt = 1;&#10;    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)) &lt; 0) {&#10;        perror(&quot;setsockopt failed&quot;);&#10;        close(sockfd);&#10;        return -1;&#10;    }&#10;&#10;    struct sockaddr_in addr;&#10;    memset(&amp;addr, 0, sizeof(addr));&#10;    addr.sin_family = AF_INET;&#10;    addr.sin_addr.s_addr = htonl(INADDR_ANY);&#10;    addr.sin_port = htons(port);&#10;&#10;    if (bind(sockfd, (struct sockaddr*)&amp;addr, sizeof(addr)) &lt; 0) {&#10;        perror(&quot;bind failed&quot;);&#10;        close(sockfd);&#10;        return -1;&#10;    }&#10;&#10;    if (listen(sockfd, 128) &lt; 0) {&#10;        perror(&quot;listen failed&quot;);&#10;        close(sockfd);&#10;        return -1;&#10;    }&#10;&#10;    return sockfd;&#10;}&#10;&#10;static void reject_with_503(int client_fd) {&#10;    const char* response = &quot;HTTP/1.1 503 Service Unavailable\r\nContent-Length: 0\r\nConnection: close\r\n\r\n&quot;;&#10;    ssize_t sent = write(client_fd, response, strlen(response));&#10;    if (sent &lt; 0) {&#10;        perror(&quot;Failed to send 503 response&quot;);&#10;    }&#10;    close(client_fd);&#10;}&#10;&#10;void enqueue_connection(shared_data_t* data, semaphores_t* sems, int client_fd) {&#10;    if (sem_trywait(sems-&gt;empty_slots) != 0) {&#10;        if (errno == EAGAIN) { // When semaphore couldn't decrement because the queue is full&#10;            reject_with_503(client_fd);&#10;            return;&#10;        } else {&#10;            reject_with_503(client_fd);&#10;            return;&#10;        }&#10;    }&#10;&#10;    sem_wait(sems-&gt;queue_mutex);&#10;&#10;    // Add to queue&#10;    data-&gt;queue.sockets[data-&gt;queue.rear] = client_fd;&#10;    data-&gt;queue.rear = (data-&gt;queue.rear + 1) % MAX_QUEUE_SIZE;&#10;    data-&gt;queue.count++;&#10;&#10;    sem_post(sems-&gt;queue_mutex);&#10;    sem_post(sems-&gt;filled_slots);&#10;}&#10;&#10;int dequeue_connection(shared_data_t* data, semaphores_t* sems) {&#10;    // Semaphores wait&#10;    sem_wait(sems-&gt;filled_slots); // Wait until there is a connection in the queue&#10;    sem_wait(sems-&gt;queue_mutex); // Wait until the queue mutex is free&#10;&#10;    int client_fd = data-&gt;queue.sockets[data-&gt;queue.front]; // Get the front connection&#10;&#10;    data-&gt;queue.front = (data-&gt;queue.front + 1) % MAX_QUEUE_SIZE; // Move front pointer&#10;    data-&gt;queue.count--; // Decrement queue size&#10;&#10;    sem_post(sems-&gt;queue_mutex); // Release queue mutex&#10;    sem_post(sems-&gt;empty_slots); // Release empty slots semaphore&#10;&#10;    return client_fd;&#10;}&#10;&#10;// Feature 1: Connection queue&#10;void connection_handler(shared_data_t* data, semaphores_t* sems) {&#10;    //Master process accpts connections (producer)&#10;&#10;    //Create a socket and listen for incoming connections&#10;    int server_fd = create_server_socket(8080);&#10;    if (server_fd &lt; 0) {&#10;        perror(&quot;Failed to create server socket&quot;);&#10;        return;&#10;    }&#10;&#10;    while (keep_running) {&#10;        int client_fd = accept(server_fd, NULL, NULL);&#10;        if (client_fd &lt; 0) {&#10;            if (errno == EINTR &amp;&amp; !keep_running) {&#10;                // Interrupted by signal, exit gracefully&#10;                break;&#10;            }&#10;            perror(&quot;Failed to accept connection&quot;);&#10;            continue;&#10;        }&#10;        enqueue_connection(data, sems, client_fd);&#10;    }&#10;&#10;    close(server_fd);&#10;}&#10;&#10;// Threads workers (consumers)&#10;void* worker_thread(void* arg) {&#10;    thread_args_t* args = (thread_args_t*)arg;&#10;    shared_data_t* data = args-&gt;data;&#10;    semaphores_t* sems = args-&gt;sems;&#10;&#10;    while (keep_running) {&#10;        int client_fd = dequeue_connection(data, sems); //Dequeue a connection&#10;        if (client_fd &lt; 0) { //If there are no more connections, exit the thread&#10;            break;&#10;        }&#10;&#10;        // Read HTTP request from client&#10;        char buffer[4096];&#10;        ssize_t bytes_read = read(client_fd, buffer, sizeof(buffer) - 1);&#10;        if (bytes_read &gt; 0) {&#10;            buffer[bytes_read] = '\0';&#10;            // Send HTTP response&#10;            const char* body = &quot;&lt;h1&gt;OK&lt;/h1&gt;\r\n&quot;;&#10;            int body_len = strlen(body);&#10;            char response[1024];&#10;            int response_len = snprintf(response, sizeof(response),&#10;                &quot;HTTP/1.1 200 OK\r\n&quot;&#10;                &quot;Content-Type: text/html\r\n&quot;&#10;                &quot;Content-Length: %d\r\n&quot;&#10;                &quot;Connection: close\r\n&quot;&#10;                &quot;\r\n&quot;,&#10;                body_len);&#10;            &#10;            ssize_t bytes_written = write(client_fd, response, response_len);&#10;            if (bytes_written &gt; 0) {&#10;                bytes_written = write(client_fd, body, body_len);&#10;                if (bytes_written &lt; 0) {&#10;                    perror(&quot;Failed to write body to client&quot;);&#10;                }&#10;            } else {&#10;                perror(&quot;Failed to write header to client&quot;);&#10;            }&#10;        } else if (bytes_read &lt; 0) {&#10;            perror(&quot;Failed to read from client&quot;);&#10;        }&#10;&#10;        close(client_fd);&#10;    }&#10;&#10;    return NULL;&#10;}&#10;&#10;int main() {&#10;    //Create shared memory&#10;    shared_data_t* data = create_shared_memory();&#10;    if (data == NULL) {&#10;        perror(&quot;Failed to create shared memory&quot;);&#10;        exit(1);&#10;    }&#10;&#10;    // Declare semaphores&#10;    sem_t empty_slots, filled_slots, queue_mutex;&#10;    semaphores_t sems;&#10;    sems.empty_slots = &amp;empty_slots;&#10;    sems.filled_slots = &amp;filled_slots;&#10;    sems.queue_mutex = &amp;queue_mutex;&#10;&#10;    //Initialize semaphores&#10;    sem_init(sems.empty_slots, 0, MAX_QUEUE_SIZE);&#10;    sem_init(sems.filled_slots, 0, 0);&#10;    sem_init(sems.queue_mutex, 0, 1);&#10;&#10;    // Install signal handler for graceful shutdown&#10;    signal(SIGINT, signal_handler);&#10;    signal(SIGTERM, signal_handler);&#10;&#10;    // Declare thread arguments&#10;    thread_args_t args;&#10;    args.data = data;&#10;    args.sems = &amp;sems;&#10;&#10;    //Declare worker thread&#10;    pthread_t workers[MAX_WORKERS];&#10;&#10;    // Create worker threads&#10;    for (int i = 0; i &lt; MAX_WORKERS; i++) {&#10;        pthread_create(&amp;workers[i], NULL, worker_thread, &amp;args);&#10;    }&#10;&#10;    //Execute connection handler&#10;    connection_handler(data, &amp;sems);&#10;&#10;    //Wait for all workers to finish&#10;    for (int i = 0; i &lt; MAX_WORKERS; i++) {&#10;        pthread_join(workers[i], NULL);&#10;    }&#10;&#10;    //Cleanup semaphores&#10;    sem_destroy(sems.empty_slots);&#10;    sem_destroy(sems.filled_slots);&#10;    sem_destroy(sems.queue_mutex);&#10;&#10;    //Remove shared memory&#10;    destroy_shared_memory(data);&#10;&#10;    return 0;&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/semaphores.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/semaphores.c" />
              <option name="originalContent" value="#include &quot;semaphores.h&quot;&#10;#include &lt;fcntl.h&gt;&#10;&#10;// Inicializa e dentroi POSIX semaforos usados na sincronização com um servidor multi-theread&#10;int init_semaphores(semaphores_t* sems, int queue_size) {&#10;    sems-&gt;empty_slots = sem_open(&quot;/ws_empty&quot;, O_CREAT, 0666, queue_size);&#10;    sems-&gt;filled_slots = sem_open(&quot;/ws_filled&quot;, O_CREAT, 0666, 0);&#10;    sems-&gt;queue_mutex = sem_open(&quot;/ws_queue_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;stats_mutex = sem_open(&quot;/ws_stats_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;log_mutex = sem_open(&quot;/ws_log_mutex&quot;, O_CREAT, 0666, 1);&#10;&#10;    if (sems-&gt;empty_slots == SEM_FAILED || sems-&gt;filled_slots == SEM_FAILED || sems-&gt;queue_mutex == SEM_FAILED || sems-&gt;stats_mutex == SEM_FAILED || sems-&gt;log_mutex == SEM_FAILED) {&#10;        return -1;&#10;    }&#10;    return 0;&#10;}&#10;&#10;void destroy_semaphores(semaphores_t* sems) {&#10;&#10;    sem_close(sems-&gt;empty_slots);&#10;    sem_close(sems-&gt;filled_slots);&#10;    sem_close(sems-&gt;queue_mutex);&#10;    sem_close(sems-&gt;stats_mutex);&#10;    _close(sems-&gt;log_mutex);&#10;&#10;    sem_unlink(&quot;/ws_empty&quot;);&#10;    sem_unlink(&quot;/ws_filled&quot;);&#10;    sem_unlink(&quot;/ws_queue_mutex&quot;);&#10;    sem_unlink(&quot;/ws_stats_mutex&quot;);&#10;" />
              <option name="updatedContent" value="#include &quot;semaphores.h&quot;&#10;#include &lt;fcntl.h&gt;&#10;&#10;// Inicializa e dentroi POSIX semaforos usados na sincronização com um servidor multi-theread&#10;int init_semaphores(semaphores_t* sems, int queue_size) {&#10;    sems-&gt;empty_slots = sem_open(&quot;/ws_empty&quot;, O_CREAT, 0666, queue_size);&#10;    sems-&gt;filled_slots = sem_open(&quot;/ws_filled&quot;, O_CREAT, 0666, 0);&#10;    sems-&gt;queue_mutex = sem_open(&quot;/ws_queue_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;stats_mutex = sem_open(&quot;/ws_stats_mutex&quot;, O_CREAT, 0666, 1);&#10;    sems-&gt;log_mutex = sem_open(&quot;/ws_log_mutex&quot;, O_CREAT, 0666, 1);&#10;&#10;    if (sems-&gt;empty_slots == SEM_FAILED || sems-&gt;filled_slots == SEM_FAILED || sems-&gt;queue_mutex == SEM_FAILED || sems-&gt;stats_mutex == SEM_FAILED || sems-&gt;log_mutex == SEM_FAILED) {&#10;        return -1;&#10;    }&#10;    return 0;&#10;}&#10;&#10;void destroy_semaphores(semaphores_t* sems) {&#10;    if (!sems) return;&#10;&#10;    sem_close(sems-&gt;empty_slots);&#10;    sem_close(sems-&gt;filled_slots);&#10;    sem_close(sems-&gt;queue_mutex);&#10;    sem_close(sems-&gt;stats_mutex);&#10;    sem_close(sems-&gt;log_mutex);&#10;&#10;    sem_unlink(&quot;/ws_empty&quot;);&#10;    sem_unlink(&quot;/ws_filled&quot;);&#10;    sem_unlink(&quot;/ws_queue_mutex&quot;);&#10;    sem_unlink(&quot;/ws_stats_mutex&quot;);&#10;    sem_unlink(&quot;/ws_log_mutex&quot;);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/thread_pool.c">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/thread_pool.c" />
              <option name="originalContent" value="#include &quot;thread_pool.h&quot;&#10;#include &lt;stdlib.h&gt;&#10;&#10;// É o loop principal para um worker numa thread pool&#10;// Espera pelo trabalho para estar disponviel e verifica se a pool esta a ser deslifada&#10;// Processa as tarefas da queue&#10;// Se o shutdown flag for ativado, sai do loop e termina a thread e o loop termina&#10;// Garante que todas as threads terminem ao desligar a pool&#10;&#10;void* worker_thread(void* arg) {&#10;    thread_pool_t* pool = (thread_pool_t*)arg;&#10;&#10;    while (1) {&#10;        pthread_mutex_lock(&amp;pool-&gt;mutex);&#10;&#10;        while (!pool-&gt;shutdown /* &amp;&amp; queue is empty */) {&#10;            pthread_cond_wait(&amp;pool-&gt;cond, &amp;pool-&gt;mutex);&#10;        }&#10;&#10;        if (pool-&gt;shutdown) {&#10;            pthread_mutex_unlock(&amp;pool-&gt;mutex);&#10;            break;&#10;        }&#10;&#10;        // Dequeue work item and process&#10;&#10;        pthread_mutex_unlock(&amp;pool-&gt;mutex);&#10;    }&#10;    return NULL;&#10;}&#10;&#10;thread_pool_t* create_thread_pool(int num_threads) {&#10;    thread_pool_t* pool = malloc(sizeof(thread_pool_t));&#10;    pool-&gt;threads = malloc(sizeof(pthread_t) * num_threads);&#10;    pool-&gt;num_threads = num_threads;&#10;    pool-&gt;shutdown = 0;&#10;&#10;    pthread_mutex_init(&amp;pool-&gt;mutex, NULL);&#10;    pthread_cond_init(&amp;pool-&gt;cond, NULL);&#10;&#10;    for (int i = 0; i &lt; num_threads; i++) {&#10;        pthread_create(&amp;pool-&gt;threads[i], NULL, worker_thread, pool);&#10;    }&#10;&#10;    return pool;&#10;}" />
              <option name="updatedContent" value="#include &quot;thread_pool.h&quot;&#10;#include &lt;stdlib.h&gt;&#10;&#10;// É o loop principal para um worker numa thread pool&#10;// Espera pelo trabalho para estar disponviel e verifica se a pool esta a ser deslifada&#10;// Processa as tarefas da queue&#10;// Se o shutdown flag for ativado, sai do loop e termina a thread e o loop termina&#10;// Garante que todas as threads terminem ao desligar a pool&#10;&#10;// worker_thread is now defined in master.c&#10;&#10;thread_pool_t* create_thread_pool(int num_threads) {&#10;    thread_pool_t* pool = malloc(sizeof(thread_pool_t));&#10;    pool-&gt;threads = malloc(sizeof(pthread_t) * num_threads);&#10;    pool-&gt;num_threads = num_threads;&#10;    pool-&gt;shutdown = 0;&#10;&#10;    pthread_mutex_init(&amp;pool-&gt;mutex, NULL);&#10;    pthread_cond_init(&amp;pool-&gt;cond, NULL);&#10;&#10;    for (int i = 0; i &lt; num_threads; i++) {&#10;        pthread_create(&amp;pool-&gt;threads[i], NULL, worker_thread, pool);&#10;    }&#10;&#10;    return pool;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>