\documentclass[a4paper,12pt]{article}

% --- Essential Packages ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{parskip}

% --- Page Configuration ---
\geometry{margin=2.5cm, top=3cm, bottom=3cm}

% --- Color Scheme (Standard Black/White) ---
\definecolor{codegray}{gray}{0.95}

% --- Hyperlink Configuration ---
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=black,
    citecolor=black,
    pdftitle={User Manual - Concurrent HTTP Web Server},
    pdfauthor={Martim Gil, Nuno Leite Faria}
}

% --- Code Style ---
\lstset{
    backgroundcolor=\color{codegray},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{black},
    numbers=none,
    captionpos=b,
    keywordstyle=\bfseries,
    commentstyle=\itshape,
    stringstyle=\ttfamily,
    showstringspaces=false,
    tabsize=4,
    xleftmargin=1em,
    xrightmargin=1em,
    aboveskip=1em,
    belowskip=1em
}

% --- Header and Footer ---
\setlength{\headheight}{14pt}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\small\textit{Concurrent HTTP Web Server}}
\fancyhead[R]{\small\textit{User Manual}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0pt}

% --- Section Styling ---
\titleformat{\section}{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% --- List Styling ---
\setlist[itemize]{noitemsep, topsep=0.5em}
\setlist[enumerate]{noitemsep, topsep=0.5em}

\begin{document}

% =================================================================
% TITLE PAGE
% =================================================================
\begin{titlepage}
    \centering
    
    % --- DETI Logo ---
    \vspace*{2cm}
    \includegraphics[width=0.7\textwidth]{deti.png}
    
    \vspace{3cm}
    
    % --- Document Title ---
    {\Huge\textbf{User Manual}}\\[0.5cm]
    {\LARGE Concurrent HTTP Web Server}
    
    \vspace{1.5cm}
    
    % --- Decorative Line ---
    \rule{0.6\textwidth}{0.5pt}
    
    \vspace{1.5cm}
    
    % --- Course Information ---
    {\Large\textbf{Operating Systems}}\\[0.3cm]
    {\large Academic Year 2025/2026}
    
    \vspace{2cm}
    
    % --- Authors ---
    \begin{tabular}{cc}
        \textbf{Martim Gil} & \textbf{Nuno Leite Faria} \\
        Student ID: 124833 & Student ID: 112994 \\
    \end{tabular}
    
    \vspace{1.5cm}
    
    % --- Supervisor ---
    {\large Supervisor: Prof. Pedro Azevedo Fernandes}
    
    \vfill
    
    % --- Date ---
    {\large \today}
    
\end{titlepage}

% --- Table of Contents ---
\tableofcontents
\newpage


% =================================================================
% 1. INTRODUCTION
% =================================================================
\section{Introduction}
This user manual provides guidance for installing, configuring, and operating the Concurrent HTTP Server.
The system is designed as a multi-threaded web server capable of handling multiple simultaneous client connections efficiently while ensuring synchronization, reliability, and safe resource management.

The primary objective of the Concurrent HTTP Server is to deliver static web content—such as HTML pages, CSS stylesheets, and multimedia files—directly from the local \texttt{www/} directory to connected clients via the HTTP/1.0 protocol.  
Internally, the server employs a hybrid process–thread model that combines interprocess communication (IPC), shared memory statistics tracking, and a thread pool for request handling.  
This design allows the server to maintain high throughput and responsiveness under concurrent workloads without compromising stability.

The manual is intended for users who wish to:
\begin{itemize}
  \item Build and launch the server from source code using the provided \texttt{Makefile}.
  \item Understand the directory structure, configuration files, and runtime behavior.
  \item Execute standard and stress tests to validate the server’s performance.
  \item Monitor real-time server statistics and logs through auxiliary utilities.
\end{itemize}

Each subsequent section of this document describes a specific aspect of system usage, including installation steps, configuration parameters, command-line execution, monitoring, and troubleshooting procedures.  
Screenshots, sample commands, and expected outputs are provided where appropriate to facilitate smooth deployment and operation.

In summary, this manual serves as a comprehensive reference for both technical and non-technical users to effectively install, operate, and evaluate the concurrent HTTP server in a POSIX-compliant environment.
% =================================================================
% 2. SYSTEM REQUIREMENTS
% =================================================================
\section{System Requirements}
The Concurrent HTTP Server is designed to operate in a POSIX-compliant environment supporting multi-threading and interprocess communication.  
This section outlines the minimum and recommended system requirements needed to build, execute, and evaluate the application successfully.

\subsection{Software Requirements}
The server and its utilities rely on standard POSIX libraries and tools commonly available on Unix-like operating systems.

\begin{itemize}
  \item \textbf{Operating System:} Linux or any POSIX-compliant system.
  \item \textbf{Compiler:} GCC version 9.0 or higher (tested with GCC 13).
  \item \textbf{Build System:} GNU \texttt{make} utility for automated compilation and testing.
  \item \textbf{Threading Support:} POSIX Threads (pthreads) library.
  \item \textbf{IPC Support:} POSIX Shared Memory (\texttt{shm\_open}) and Semaphores (\texttt{sem\_open}).
  \item \textbf{Shell Environment:} Bash 4.0+ (for executing test scripts such as \texttt{test\_suite.sh} and \texttt{stress\_test.sh}).
  \item \textbf{Optional Tools:}
    \begin{itemize}
      \item \texttt{curl} — for manual HTTP testing.
      \item \texttt{ab} (ApacheBench) — for concurrency and performance testing.
      \item \texttt{valgrind}, \texttt{helgrind}, or \texttt{tsan} — for memory and thread-safety analysis.
    \end{itemize}
\end{itemize}

\subsection{Dependencies and Libraries}
All required dependencies are part of the standard GNU/Linux environment.  
The following libraries are automatically linked during the build process via the \texttt{Makefile}:
\begin{itemize}
  \item \texttt{-pthread} — for thread creation and synchronization.
  \item \texttt{-lrt} — for POSIX real-time extensions used in shared memory and semaphores.
  \item \texttt{-lm} — for standard mathematical functions.
\end{itemize}

\subsection{Test Environment}
The system was developed and validated on Ubuntu 24.04 LTS (64-bit) with kernel version 6.x and GCC 13.2.0.  
All functional and concurrency tests were executed locally on both physical and virtualized environments without external dependencies.

\subsection{User Permissions}
Running the server requires user-level permissions only.  
Administrator privileges (\texttt{sudo}) are not required unless the user wishes to bind the server to a privileged port (below 1024).  
For standard operation, the default configuration uses TCP port 8080.

% =================================================================
% 3. COMPILATION
% =================================================================
\section{Compilation}
The Concurrent HTTP Server project is built using a GNU \texttt{Makefile} that automates compilation, linking, and testing tasks.  
All compilation rules are compatible with POSIX systems using the \texttt{gcc} compiler and the GNU \texttt{make} utility.

\subsection{Build System Overview}
The Makefile separates source code, build artifacts, and final binaries into dedicated directories:
\begin{verbatim}
src/      → C source files and headers
build/    → Intermediate object (.o) and dependency (.d) files
bin/      → Final executables (webserver, stats_reader)
tests/    → Test scripts and utilities
\end{verbatim}

The compilation process automatically generates dependency files using the compiler flags \texttt{-MMD -MP}, allowing incremental builds to recompile only modified files.  
POSIX threading and real-time libraries are linked through the flags \texttt{-pthread} and \texttt{-lrt}, ensuring full compatibility with shared memory and semaphore operations.

\subsection{Standard Build}
To compile the complete project (main server and statistics reader), navigate to the project root and execute:
\begin{lstlisting}[language=bash]
make all
\end{lstlisting}

This target performs the following steps:
\begin{itemize}
  \item Creates required directories (\texttt{build/} and \texttt{bin/}).
  \item Compiles all C sources located in \texttt{src/}.
  \item Links the main server executable \texttt{bin/webserver}.
  \item Builds the auxiliary utility \texttt{bin/stats\_reader}.
\end{itemize}

On success, both executables are available in the \texttt{bin/} directory:

\begin{verbatim}
bin/
|-- webserver      -> Main HTTP server binary
`-- stats_reader   -> Shared memory monitoring utility
\end{verbatim}

\subsection{Running the Server}
Once compiled, the server can be launched directly via the Makefile:
\begin{lstlisting}[language=bash]
make run
\end{lstlisting}

This command builds the project (if necessary) and executes \texttt{./bin/webserver} with default configuration parameters specified in \texttt{server.conf}.

\subsection{Cleaning Build Artifacts}
To remove all intermediate and binary files, execute:
\begin{lstlisting}[language=bash]
make clean
\end{lstlisting}
This command deletes the \texttt{build/} and \texttt{bin/} directories, ensuring a clean state for subsequent recompilation or testing.

\subsection{Debug and Analysis Builds}
The Makefile includes predefined targets for debugging and race detection:

\begin{itemize}
  \item \textbf{Debug Mode} — builds the project with extended debug symbols and preprocessor macros:
        \begin{lstlisting}[language=bash]
        make debug
        \end{lstlisting}
        This enables additional logging and verbose output, suitable for development and inspection via \texttt{gdb} or similar tools.

  \item \textbf{Thread Sanitizer (TSan)} — compiles the project with the GCC/Clang Thread Sanitizer:
        \begin{lstlisting}[language=bash]
        make tsan
        ./bin/webserver
        \end{lstlisting}
        This mode detects race conditions and synchronization misuse at runtime.

  \item \textbf{Helgrind (Valgrind Tool)} — while not a separate Make target, race detection can also be run through:
        \begin{lstlisting}[language=bash]
        valgrind --tool=helgrind ./bin/webserver
        \end{lstlisting}
        This approach identifies data races and lock-order inversions in multithreaded execution.

  \item \textbf{Valgrind Leak Check} — to verify proper resource cleanup:
        \begin{lstlisting}[language=bash]
        valgrind --leak-check=full ./bin/webserver
        \end{lstlisting}
        confirming that all heap, shared memory, and semaphore allocations are correctly freed upon shutdown.
\end{itemize}

\subsection{Testing Integration}
Automated validation is directly integrated into the build system via the following targets:
\begin{lstlisting}[language=bash]
make test         # Executes the test suite (tests/test_suite.sh)
make build-tests  # Compiles test binaries (e.g., test_concurrent.c)
\end{lstlisting}

The \texttt{make test} target compiles and launches the server before running a collection of automated scripts that verify HTTP compliance, concurrency safety, and log consistency.  
Additional stress tests can be launched via:
\begin{lstlisting}[language=bash]
./tests/stress_test.sh
\end{lstlisting}
to evaluate performance under sustained load.

\subsection{Help and Documentation}
The Makefile provides a built-in help command summarizing all available targets:
\begin{lstlisting}[language=bash]
make help
\end{lstlisting}
This command lists build, clean, test, and debug options with brief descriptions, ensuring that all project operations can be performed consistently from the command line.

% =================================================================
% 4. CONFIGURATION
% =================================================================
\section{Configuration}
The behavior of the Concurrent HTTP Server is governed by the configuration file \texttt{server.conf}, located in the project root directory.  
This file defines all runtime parameters, including network settings, concurrency levels, and resource allocation limits.  
The configuration is parsed at startup by the \texttt{config.c} module, which reads each key–value pair, validates the input, and applies the settings to the master and worker processes.

If the file is missing or a parameter is invalid, the server automatically falls back to default values defined in the source code.  
Any configuration error or invalid syntax is reported to the console and logged in the main log file.

\subsection{Editing the Configuration File}
The configuration file uses a simple line-based \texttt{KEY = VALUE} format.  
Comments are supported using the \texttt{\#} symbol at the start of a line.  
For example:
\begin{lstlisting}[language=bash]
# Example server configuration
PORT = 8080
DOCUMENT_ROOT = www
NUM_WORKERS = 4
THREADS_PER_WORKER = 10
MAX_QUEUE_SIZE = 100
LOG_FILE = logs/server.log
CACHE_SIZE_MB = 10
\end{lstlisting}

Blank lines and extra whitespace are ignored.  
All paths can be specified relative to the project root or as absolute filesystem paths.

\subsection{Configuration Parameters}
\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{8cm}|}
\hline
\textbf{Parameter} & \textbf{Example} & \textbf{Description} \\ \hline

\texttt{PORT} & 8080 &
TCP port on which the master process listens for incoming HTTP connections.  
Must be greater than 1024 for non-root users. \\ \hline

\texttt{TIMEOUT\_SECONDS} & 30 &
Maximum duration (in seconds) that an idle client connection may remain open.  
After this period, inactive connections are automatically closed to conserve resources. \\ \hline

\texttt{DOCUMENT\_ROOT} & ./www &
Directory containing the static web content (HTML, CSS, JavaScript, images, and other resources) served by the server.  
Paths can be absolute or relative to the project root. \\ \hline

\texttt{NUM\_WORKERS} & 4 &
Number of worker processes forked by the master process.  
Each worker manages an independent thread pool for request handling. \\ \hline

\texttt{THREADS\_PER\_WORKER} & 10 &
Number of threads created within each worker process.  
Each thread handles one client connection at a time, allowing parallel request servicing. \\ \hline

\texttt{MAX\_QUEUE\_SIZE} & 100 &
Maximum number of pending client requests in the bounded task queue between the acceptor and worker threads.  
Higher values increase tolerance to bursts of connections but may consume more memory. \\ \hline

\texttt{CACHE\_SIZE\_MB} & 10 &
Size (in megabytes) of the Least Recently Used (LRU) cache maintained by each worker.  
Larger caches improve response times for frequently requested files at the cost of additional memory usage. \\ \hline

\texttt{LOG\_FILE} & access.log &
Path to the access log file where all client requests and system messages are recorded.  
Writes are synchronized across processes using semaphores to avoid interleaved output. \\ \hline

\end{tabular}
\caption{Updated configuration parameters as defined in \texttt{server.conf}.}
\end{table}


\subsection{Runtime Behavior}
When the server starts, the \texttt{master.c} process reads and applies these parameters before spawning worker processes.  
Each worker initializes its own LRU cache and thread pool according to the configuration values.  
The \texttt{logger.c} module initializes a shared semaphore-protected log file defined by \texttt{LOG\_FILE}, ensuring non-interleaved writes from multiple threads.

Configuration values such as \texttt{MAX\_QUEUE\_SIZE} and \texttt{CACHE\_SIZE\_MB} directly affect performance and memory footprint.  
Increasing these parameters can improve throughput but requires more system memory and may impact scheduling latency.

\subsection{Parameter Requirements}

\paragraph{Required keys.}
The following keys must be present and valid:
\begin{itemize}
  \item \texttt{PORT} (integer $>$ 0 and typically $>$ 1024 for non-root users)
  \item \texttt{DOCUMENT\_ROOT} (existing directory)
  \item \texttt{NUM\_WORKERS} (positive integer)
  \item \texttt{THREADS\_PER\_WORKER} (positive integer)
  \item \texttt{MAX\_QUEUE\_SIZE} (non-negative integer)
  \item \texttt{CACHE\_SIZE\_MB} (non-negative integer)
  \item \texttt{LOG\_FILE} (writable path)
  \item \texttt{TIMEOUT\_SECONDS} (non-negative integer)
  \item \texttt{LOG\_LEVEL} (\texttt{DEBUG|INFO|WARN|ERROR})
\end{itemize}

\subsection{Validation and Error Handling}
Each configuration parameter is validated at startup:
\begin{itemize}
  \item Invalid numeric values (negative or zero) are rejected and replaced with defaults.
  \item Nonexistent directories in \texttt{DOCUMENT\_ROOT} or \texttt{LOG\_FILE} paths trigger warnings and cause fallback creation.
  \item Invalid or unknown keys are ignored but reported in the log.
\end{itemize}

If any critical parameter (such as the listening port) cannot be initialized, the server prints an error message and terminates gracefully.

\subsection{Reloading Configuration}
Currently, configuration parameters are loaded only at startup.  
To apply changes, the server must be restarted:
\begin{lstlisting}[language=bash]
make run
# or
./bin/webserver
\end{lstlisting}

This approach ensures deterministic initialization and avoids inconsistencies during live configuration updates.

% =================================================================
% 5. EXECUTION
% =================================================================
\section{Execution}

\subsection{Starting the Server}
After compilation, start the server with:
\begin{lstlisting}[language=bash]
./bin/webserver
# Or via make:
make run
\end{lstlisting}

\subsection{Graceful Shutdown}
To stop the server correctly (releasing shared memory and closing sockets):
\begin{enumerate}
    \item Press \textbf{Ctrl+C} (sends \texttt{SIGINT}) in the terminal running the server.
    \item The Master process will catch the signal, notify workers, and clean up resources.
    \item Wait for the "Server shutdown complete" message.
\end{enumerate}

% =================================================================
% 6. USAGE EXAMPLES
% =================================================================
\section{Usage Examples}

This section provides practical examples of how to interact with the Concurrent HTTP Server once it has been compiled and configured.  
The examples assume that the server has been started successfully using either:
\begin{lstlisting}[language=bash]
make run
# or
./bin/webserver
\end{lstlisting}
and that it is listening on TCP port 8080 as defined in the configuration file (\texttt{server.conf}).

% ----------------------------------------------------------------------
\subsection{Basic HTTP Request}
% ----------------------------------------------------------------------

The server delivers static files stored in the directory specified by the \texttt{DOCUMENT\_ROOT} parameter (default: \texttt{www/}).  
To test the server using the command line, use \texttt{curl} to request a file:

\begin{lstlisting}[language=bash]
curl -v http://127.0.0.1:8080/index.html
\end{lstlisting}

The \texttt{-v} flag enables verbose output, displaying HTTP headers and response codes.  
If the file exists in the \texttt{www/} directory, the server responds with:
\begin{lstlisting}
> GET /index.html HTTP/1.0
< HTTP/1.0 200 OK
< Content-Type: text/html
< Content-Length: 512
\end{lstlisting}

If the file is not found, the server returns the predefined error page:
\begin{lstlisting}
< HTTP/1.0 404 Not Found
< Content-Type: text/html
< Content-Length: 238
\end{lstlisting}

To view a list of other available files:
\begin{lstlisting}[language=bash]
ls www/
\end{lstlisting}

 


\subsection{Accessing from a Web Browser}
After launching the server, open any browser and navigate to:
\begin{verbatim}
http://localhost:8080
\end{verbatim}
You should see the default landing page (\texttt{index.html}) loaded from the local \texttt{www/} directory.  
The server will log each access in the file defined by the \texttt{LOG\_FILE} parameter (default: \texttt{logs/server.log}).

 

\subsection{Monitoring Logs}
All requests and internal events are recorded in the log file.  
To view logs in real time:
\begin{lstlisting}[language=bash]
tail -f logs/server.log
\end{lstlisting}

Each log entry contains a timestamp, process ID, thread ID, client IP, and the requested resource.  
Concurrent access from multiple clients is safely synchronized through semaphores, ensuring clean, non-interleaved lines.

 

\subsection{Checking Live Statistics}
The server maintains real-time statistics on shared memory, including request counts, cache hits, and bytes served.  
These can be viewed using the monitoring utility:
\begin{lstlisting}[language=bash]
./bin/stats_reader
\end{lstlisting}

Typical output:
\begin{lstlisting}
=== Server Statistics ===
Total Requests=N
Bytes Requests=X
Status_200=Y
Status_404=Z
Status_500=A
Active Connections=B
Total_response_time_ms=C
Avg_response_time_ms=D
=========================

*The letters correspond to variable numbers
\end{lstlisting}

Statistics are refreshed periodically (default: every 30 seconds).  
If run in a separate terminal, \texttt{stats\_reader} provides a non-intrusive live view of the server’s performance.

 

\subsection{Concurrent Request Example}
To simulate multiple simultaneous clients, use the Apache Benchmark tool (\texttt{ab}):

\begin{lstlisting}[language=bash]
ab -n 200 -c 20 http://127.0.0.1:8080/index.html
\end{lstlisting}

where:
\begin{itemize}
  \item \texttt{-n 200} — total number of requests.
  \item \texttt{-c 20} — number of concurrent clients.
\end{itemize}

The output displays average latency, throughput, and failed request counts, allowing quick performance evaluation under load.

 

\subsection{Error Handling Verification}
To test custom error pages:
\begin{lstlisting}[language=bash]
curl -v http://127.0.0.1:8080/nonexistent.html
\end{lstlisting}
Expected response:
\begin{lstlisting}
< HTTP/1.0 404 Not Found
< Content-Type: text/html
< Content-Length: 238
\end{lstlisting}

This confirms that the server correctly maps missing files to the predefined error template located in \texttt{www/errors/404.html}.

% ----------------------------------------------------------------------
\subsection{Web Dashboard (Bonus Feature)}
% ----------------------------------------------------------------------

The project includes a fully self-contained Web Dashboard, implemented in
\texttt{www/dashboard.html}. This optional component provides a modern
browser-based interface for real-time server monitoring. It uses
\textbf{TailwindCSS} for layout and design, \textbf{Chart.js} for
visualization, and periodically fetches live metrics from the backend endpoint
\texttt{/api/stats} in JSON format.

\paragraph{Accessing the Dashboard.}
After starting the server, open any web browser and navigate to:
\begin{verbatim}
http://localhost:8080/dashboard.html
\end{verbatim}
The page is automatically refreshed every two seconds to display current
server statistics.

\paragraph{Displayed Information.}
The dashboard presents an overview of runtime metrics including:
\begin{itemize}
  \item \textbf{Total Requests} – cumulative number of handled HTTP requests.
  \item \textbf{Data Transferred} – total outgoing bandwidth.
  \item \textbf{Average Response Time} – mean latency in milliseconds.
  \item \textbf{Active Connections} – number of concurrent client sessions.
  \item \textbf{HTTP Status Distribution} – counters for 200, 404, and 500
        responses.
  \item \textbf{Cache Performance} – hit/miss counts and calculated hit rate.
  \item \textbf{Requests per Second Chart} – dynamic time-series graph showing
        recent load levels.
\end{itemize}

\paragraph{Technology Stack.}
\begin{itemize}
  \item \textbf{TailwindCSS} is loaded via CDN to provide the responsive dark
        interface without additional assets.
  \item \textbf{Chart.js} (also via CDN) renders a continuously updated line
        chart.
  \item The dashboard logic is implemented directly in inline JavaScript,
        without external dependencies or build steps.
\end{itemize}

\paragraph{Data Source (\texttt{/api/stats}).}
The page periodically issues HTTP \texttt{GET} requests to
\texttt{/api/stats}. The server must expose this endpoint and return a JSON
object with the following fields (example):
\begin{lstlisting} [language=json]
{
  "total_requests": A,
  "bytes_transferred": B,
  "avg_response_time_ms": C,
  "active_connections": D,
  "status_codes": { "200": X, "404": Y, "500": Z },
  "cache": { "hits": E, "misses": F, "hit_rate": E/(E+F) * 100 }
}
*the letters are number placeholders that can change depeding on the number of requests and their volume
\end{lstlisting}

\paragraph{Troubleshooting.}
\begin{itemize}
  \item \textbf{404 Not Found:} Ensure \texttt{dashboard.html} is present in
        the document root defined in \texttt{server.conf}.
  \item \textbf{Disconnected Status:} The indicator will turn red if
        \texttt{/api/stats} is unreachable or returns invalid JSON. Verify the
        backend implementation with:
        \begin{lstlisting}[language=bash]
        curl http://localhost:8080/api/stats
        \end{lstlisting}
  \item \textbf{Chart Not Updating:} Clear browser cache or refresh the page.
\end{itemize}

\paragraph{Summary.}
The Web Dashboard provides an intuitive and visually rich way to monitor
the HTTP server’s real-time performance. It requires no installation or
additional dependencies and is accessible at:
\begin{center}
\textbf{\texttt{http://localhost:8080/dashboard.html}}
\end{center}

 

\subsection{Graceful Shutdown}
To terminate the server, use:
\begin{lstlisting}[language=bash]
Ctrl + C
\end{lstlisting}

The server handles the \texttt{SIGINT} signal gracefully by:
\begin{itemize}
  \item Closing all open sockets.
  \item Releasing shared memory and semaphores.
  \item Flushing log buffers to disk.
\end{itemize}
After shutdown, you can verify resource cleanup using:
\begin{lstlisting}[language=bash]
ipcs -m    # Shared memory segments
ipcs -s    # Semaphores
\end{lstlisting}
No remaining entries should appear under the server’s process user.

 

% 7. TROUBLESHOOTING
% =================================================================
\section{Troubleshooting}

This section lists common issues that may occur during compilation, configuration, or runtime execution of the Concurrent HTTP Server, together with their corresponding causes and recommended solutions.  
Each problem is derived from real test and validation scenarios observed during the system’s development and evaluation.

\subsection{Compilation Issues}

\paragraph{1. Missing Libraries or Header Files.}
\textbf{Symptom:}
\begin{lstlisting}
fatal error: pthread.h: No such file or directory
fatal error: semaphore.h: No such file or directory
\end{lstlisting}

\textbf{Cause:}  
Required POSIX development libraries (\texttt{libpthread}, \texttt{librt}) are missing.

\textbf{Solution:}  
Install the development toolchain for POSIX libraries:
\begin{lstlisting}[language=bash]
sudo apt-get install build-essential
sudo apt-get install manpages-posix-dev
\end{lstlisting}
Then recompile using:
\begin{lstlisting}[language=bash]
make clean && make all
\end{lstlisting}

\paragraph{2. Undefined Reference Errors at Link Time.}
\textbf{Symptom:}
\begin{lstlisting}
undefined reference to `sem_open' or `shm_open'
\end{lstlisting}

\textbf{Cause:}  
The real-time library (\texttt{-lrt}) is not linked properly.

\textbf{Solution:}  
Ensure the Makefile includes:
\begin{lstlisting}
LDFLAGS += -lrt
\end{lstlisting}
(Already included by default in this project.)

 

\subsection{Configuration and Startup Issues}

\paragraph{3. “Port Already in Use” Error.}
\textbf{Symptom:}
\begin{lstlisting}
Error: Failed to bind socket on port 8080
\end{lstlisting}

\textbf{Cause:}  
Another process (possibly a previous server instance) is already listening on the same port.

\textbf{Solution:}
\begin{itemize}
  \item Terminate any running instance of the server:
  \begin{lstlisting}[language=bash]
  sudo lsof -i :8080
  kill <PID>
  \end{lstlisting}
  \item Alternatively, change the port in \texttt{server.conf} to an unused value (e.g., 8081).
\end{itemize}

 

\paragraph{4. “Permission Denied” on Low Ports.}
\textbf{Symptom:}
\begin{lstlisting}
bind(): Permission denied
\end{lstlisting}

\textbf{Cause:}  
Non-root users cannot bind to privileged ports (below 1024).

\textbf{Solution:}  
Either use a non-privileged port (e.g., 8080) in \texttt{server.conf}, or start the server with elevated privileges:
\begin{lstlisting}[language=bash]
sudo ./bin/webserver
\end{lstlisting}

 

\paragraph{5. Missing or Invalid Document Root.}
\textbf{Symptom:}
\begin{lstlisting}
Error: Failed to open document root directory 'www'
\end{lstlisting}

\textbf{Cause:}  
The directory specified by \texttt{DOCUMENT\_ROOT} does not exist.

\textbf{Solution:}  
Ensure the directory exists and contains at least one valid file:
\begin{lstlisting}[language=bash]
mkdir -p www
echo "<h1>Server is running!</h1>" > www/index.html
\end{lstlisting}

 

\paragraph{6. Invalid Configuration Entries.}
\textbf{Symptom:}
\begin{lstlisting}
Warning: Invalid line in server.conf: "THREADS_PER_WORKER = -2"
\end{lstlisting}

\textbf{Cause:}  
Numeric parameters cannot be negative or zero.

\textbf{Solution:}  
Edit \texttt{server.conf} to ensure all values are positive integers:
\begin{lstlisting}[language=bash]
THREADS_PER_WORKER = 4
\end{lstlisting}

 

\subsection{Runtime and Concurrency Issues}

\paragraph{7. No Response to HTTP Requests.}
\textbf{Symptom:}
\begin{lstlisting}
curl: (7) Failed to connect to 127.0.0.1 port 8080: Connection refused
\end{lstlisting}

\textbf{Cause:}  
The server process is not running, or the master process failed to spawn workers.

\textbf{Solution:}  
Run the server manually in the foreground to view debug messages:
\begin{lstlisting}[language=bash]
make run
\end{lstlisting}
Check for errors such as “Failed to fork worker” or “Invalid socket descriptor.”

 

\paragraph{8. Interleaved or Corrupted Logs.}
\textbf{Symptom:}  
Multiple log entries overlap in the same line of \texttt{logs/server.log}.

\textbf{Cause:}  
This may occur if the logging semaphore was removed or not initialized properly.

\textbf{Solution:}
\begin{lstlisting}[language=bash]
pkill webserver
sem_unlink /ws_log_sem
make run
\end{lstlisting}
The \texttt{master.c} process recreates the semaphore on startup.

 

\paragraph{9. Shared Memory Not Released After Shutdown.}
\textbf{Symptom:}
\begin{lstlisting}
ipcs -m
------ Shared Memory Segments --------
0x00000000  12345  user  666  4096
\end{lstlisting}

\textbf{Cause:}  
The server terminated abnormally (e.g., via \texttt{kill -9}), skipping cleanup routines.

\textbf{Solution:}  
Manually remove IPC objects:
\begin{lstlisting}[language=bash]
ipcrm -m 12345   # Shared memory
ipcrm -s 54321   # Semaphore
\end{lstlisting}
Then restart the server using \texttt{make run}.

 

\paragraph{10. High CPU Usage or Slow Response.}
\textbf{Cause:}  
Cache size too small or thread count too low for the incoming request rate.

\textbf{Solution:}  
Increase \texttt{THREADS\_PER\_WORKER} and \texttt{CACHE\_SIZE\_MB} in \texttt{server.conf}, or reduce concurrency levels during testing:
\begin{lstlisting}[language=bash]
ab -n 100 -c 10 http://127.0.0.1:8080/
\end{lstlisting}

 

\subsection{Testing and Validation Problems}

\paragraph{11. Test Scripts Fail to Execute.}
\textbf{Symptom:}
\begin{lstlisting}
./tests/test_suite.sh: Permission denied
\end{lstlisting}

\textbf{Cause:}  
The test scripts are missing execution permissions.

\textbf{Solution:}
\begin{lstlisting}[language=bash]
chmod +x tests/*.sh
make test
\end{lstlisting}

 

\paragraph{12. Stress Test Hangs Indefinitely.}
\textbf{Cause:}  
Thread pool exhaustion or blocked request queue due to oversized \texttt{MAX\_QUEUE\_SIZE} and insufficient consumer threads.

\textbf{Solution:}
\begin{itemize}
  \item Decrease \texttt{MAX\_QUEUE\_SIZE} to balance producer–consumer throughput.
  \item Monitor shared memory statistics using \texttt{./bin/stats\_reader}.
\end{itemize}

 
\begin{lstlisting}[language=bash]
make debug
./bin/webserver
\end{lstlisting}
This mode provides detailed trace logs that can help identify configuration or synchronization errors during runtime.

\end{document}
